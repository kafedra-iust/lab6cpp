= Лабораторна робота № 6

== Динамічний розподіл пам'яті. Лінійні зв'язані списки

=== Основні поняття

Лінійні списки — найпростіша форма організації даних з рекурсивною
структурою. Цю форму застосовують найчастіше тоді, коли треба обробити деяку
сукупність даних, кількість елементів яких заздалегідь не визначена, а взаємний
порядок проходження відіграє важливу або вирішальну роль.
Лінійний односпрямований (однозв'язний) список – дані динамічної структури,
що являють собою сукупність лінійно зв'язаних однорідних елементів, до яких
дозволяється додавати елементи на голови (початку) або в кінець (хвіст) списку,
між будь-якими двома іншими й видаляти будь-який елемент

image::img/SingleLinkedList.png[]

Даний тип можна описати в такий спосіб:

[source,c++]
----
struct element
{
    typeelem data;
    element *next;
};
----

Для роботи з лінійним однозв'язним списком потрібні такі покажчики:

. на голову списку Head;
. кінець списку Tail, але можна обійтися й без нього;
. k-й елемент списку;
. тимчасовий для виділення пам'яті під елементи, які додаються, і для
звільнення елементів, що видаляються (ідентифікатор р).

Розглянемо основні дії над однозв’язним списком.

*Ініціалізація списку*

У разі застосування покажчика на кінець списку ініціалізація буде мати такий
вигляд:

image::img/init.png[]

[source,c++]
----
element *head, *tail;
head = nullptr;
tail = nullptr;
----

або коротшим записом:
[source,c++]
element *head = nullptr, *tail = nullptr;

Якщо покажчик на кінець списку не використовують, ініціалізувати треба
тільки один покажчик:

image::img/init1.png[]

[source,c++]
----
element *head;
head = nullptr;
----

або одним рядком:

[source,c++]
element *head = nullptr;

Таким чином, список ініціалізований, але не містить жодного елемента. Тепер
можна заповнювати список з голови (додаючи знову створений елемент списку
після попередніх) або з кінця (додаючи знову створений елемент перед
попереднім).

*_Додавання елементів у список із використанням двох покажчиків (на голову
і кінець списку)_*

Додавання першого елемента в список та додавання елемента в кінець
списку відрізняється. У будь-якому випадку необхідний ще один покажчик
*р* на поточний (новий) елемент.

_Додавання першого елемента в список_

. Вихідний стан:

image::img/init.png[]

[source,c++]
----
element *head = nullptr, *tail = nullptr;
element *p;
----

[start=2]
. Виділення пам'яті під перший елемент списку й занесення інформації до
нього:

image::img/step1.png[]

[source,c++]
----
p = new element;        // виділення пам´яті під новий елемент
p->data = 42;           // присвоєння значення іформаційній частині
p->next = nullptr;      // присвоєння покажчику на наступний елемент значення ознаки кінця
----

Опис покажчика на поточний елемент і виділення пам′яті краще записувати
одним рядком:

[source,c++]
element *p = new element;

[start=3]
. Встановлення покажчиків head, tail на створений перший елемент:

image::img/step2.png[]

[source,c++]
----
head = p;
tail = p;
----

_Додавання елемента в кінець списку_

. Вихідний стан:

image::img/step1a.png[]

[start=2]
. Виділення пам'яті під новий елемент списку й занесення інформації до
нього:

image::img/step2a.png[]

[source,c++]
----
element *p = new element;
p->data = 24;            // присвоєння значення іформаційній частині
p->next = nullptr;       // присвоєння покажчику на наступний елемент значення ознаки кінця
----

[start=3]
. Встановлення зв'язку між останнім елементом списку й новим, а також
переміщення покажчика кінця списку на новий елемент:

image::img/step3a.png[]

[source,c++]
----
tail->next = p;
tail = p;
----

Функція додавання елемента в кінець списку з використанням покажчиків
head, tail може мати такий вигляд:

[source,c++]
----
void addToList(element **head, element **tail, int value)
{
    //виділення пам'яті під новий елемент списку
    element *p = new element;
    //заповнення інформаційної частини
    p->data = value;
    //встановлення посилання останнього елемента
    p->next = nullptr;
    //якщо список порожній
    if (*head == nullptr) // або if (!(*head))
        //встановлення покажчика head на перший елемент
        *head = p;
       //інакше встановлення зв'язку між останнім елементом списку й новим
    else (*tail)->next = p;
    //встановлення покажчика кінця списку на новий елемент
    *tail = p;
}
----

Під час виклику треба вказувати адреси покажчиків (покажчик на покажчик) head і tail

[source,c++]
addToList(&head, &tail, value)

*_Додавання елементів у список з використанням одного покажчика
(на голову списку)_*

Додавання першого елемента в список майже не відрізняється від аналогічної
операції з використанням двох покажчиків

_Додавання першого елемента в список_

. Вихідний стан:

image::img/step1b.png[]

[source,c++]
head = nullptr;

[start=2]
. Виділення пам'яті під перший елемент списку й занесення інформації до
нього:

image::img/step2b.png[]

[source,c++]
----
element *p= new element;
p->data = 42;
p->next = nullptr;
----

[start=3]
. Встановлення покажчика head на створений перший елемент:

image::img/step3b.png[]

[source,c++]
head = p;

Додавати елементи можна й до вже існуючого списку: в голову списку,
всередину після заданого та перед заданим елементом

_Додавання елемента в голову списку_

. Вихідний стан:

image::img/step1c.png[]

[start=2]
. Виділення пам'яті під новий елемент списку й заповнення інформаційного
поля:

image::img/step2c.png[]

[source,c++]
element *p = new element;
p->data = 5;

[start=3]
. Встановлення зв'язку між першим елементом списку й новим:

image::img/step3c.png[]

[source,c++]
p->next = head;

[start=4]
. Переміщення покажчика на голову списку на новий елемент:

image::img/step4c.png[]

[source,c++]
head = p;

Функція додавання елемента в голову списку може мати такий вигляд:

[source,c++]
void addInHead(element **head, int value)
{
    //виділення пам'яті під новий елемент списку
    element *p = new element;
    //заповнення інформаційної частини
    p->data = value;
    if (*head != nullptr) //якщо список не порожній
         //встановлення зв'язку між першим елементом списку й новим
         p->next = *head;
         //Переміщення вказівника на голову на новий елемент
    *head = p;
}

_Виведення елементів списку починаючи від голови_

Для виведення елементів списку на екран, потрібно використовувати допоміжне посилання, якому на початку надається значення голови списку. Після опрацювання кожного елемента (виведення на екран його інформаційної частини), відбувається перехід до наступного. Процес продовжується доки покажчик не стане дорівнювати nullptr через досягнення кінця списку:

[source,c++]
----
void printList(element *head) {
    element *p = head;
    while (p!=nullptr) {
        cout << p->data << " ";
        p = p->next;
    }
}
----

Також можна написати рекурсивну функцію виведення елементів списку:

[source,c++]
----
void printListRec(element *head) {
    if (head != nullptr) {
        cout << head->data << " ";
        printListRec(head->next);
    }
}
----

Для виведення всього списку представлені функції треба викликати з фактичним
параметром head, який зберігає адресу першого елемента. Функції придатні
також і для виведення на екран частини списку, для цього як фактичний параметр
треба передати адресу елемента, з якого буде починатись виведення списку.
